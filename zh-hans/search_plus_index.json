{"./":{"url":"./","title":"引言","keywords":"","body":"引言 SoCube工作流程示意 1.1 软件基本信息 全称为“浙大单细胞高通量测序二聚体检测软件”，简称“SoCube” [soʊ'kjuːb]，版本号V1.1。SoCube V1.1是使用Python编写的无可视化用户操作页面（GUI）的终端命令式软件，可以运行于任何可运行Python语言的计算服务器、个人计算机等。 1.2 编写目的 《浙大单细胞高通量测序二聚体检测软件（V1.1）用户手册》（以下简称“本手册”）是为浙大单细胞高通量测序二聚体检测软件（V1.1）的用户使用指导手册。 1.3 软件开发背景 高通量单细胞RNA测序（single-cell RNA sequencing, scRNA-seq）被广泛应用在生物医学研究中[1-6]。但由于测序技术的限制，测序过程中会产生由两个（或多个）细胞结合而成的二聚体（或多聚体）。二聚体相当于一种本不存在于样本中的细胞类型，会严重干扰细胞与基因的真实统计分布，进而影响具有分布依赖性的下游研究[7]。因此，浙江大学创新药物研究与生物信息学实验室（以下简称“我们”）开发了SoCube用于检测单细胞高通量测序产生的二聚体。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"2-requirement.html":{"url":"2-requirement.html","title":"环境依赖","keywords":"","body":"环境依赖 2.1 硬件环境 SoCube的硬件开发环境的CPU型号为十二代Gen Intel I7-12700F，GPU型号为NVIDIA GeForce RTX 3060。SoCube理论上能够适用于任何可以运行Python语言和深度学习框架PyTorch的设备，推荐硬件运行环境如下： RAM容量不小于8GB CPU核心数不小于6核 支持CUDA加速的NVIDIA独立显卡，显存不小于4GB 2.2 软件环境 SoCube使用Python语言v3.8编写，使用Visual Studio Code v1.68.1作为代码编写工具。开发时操作系统是Windows 11。SoCube支持在任何可以运行Python语言和深度学习框架PyTorch的软件环境中使用，推荐软件运行环境如下： 操作系统：Windows 10/11，Linux CentOS 7/8, Mac OS Python语言v3.7及以上 PyTorch v1.8.1及以上的GPU版本 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"3-install.html":{"url":"3-install.html","title":"软件安装","keywords":"","body":"软件安装 3.1 CUDA安装 SoCube是基于深度卷积神经网络开发的，我们强烈建议用户在有NVIDIA GPU和NVIDIA CUDA计算套件的环境下，使用GPU加速计算。对于拥有支持CUDA的NVIDIA GPU，用户首先需要安装CUDA，这个可以从NVIDIA官网下载并安装。 Nvidia cuda下载页面 安装完成后，用户可以在终端输入“nvidia-smi”，即可查看自己的显卡信息以及CUDA版本信息，如下图的显卡为GeForce RTX 3060，驱动版本为516.59，CUDA版本为11.7。 nvidia-smi nvidia-smi运行结果 3.2 SoCube安装 PipDockerpip install socube # pip安装 socube -v # 查看安装版本 SoCube已经打包发布到Python官方仓库PyPi，用户可以打开终端（如Windows PowerShell，Bash等），使用pip命令安装。对于国内用户，建议在安装时使用清华大学镜像源加速下载。下面以Windows操作系统为例介绍。1. 安装Python语言SoCube是基于Python语言开发的软件，需要依赖Python解释器来运行软件，因此需要安装。用户需要从Python官网下载Python。Python官网如下图，按安装包提示安装Python，并勾选将Python添加到PATH环境变量（该环境变量定义了终端命令的搜索路径，没有添加则无法直接在终端中使用Python）。Python安装页面2. 打开终端命令环境Pip是一个Python提供的包管理器，可以下载各类Python开发的软件包，但它需要在终端中使用。Windows下提供了Windows PowerShell和Cmd两种终端，我们推荐使用PowerShell。使用“Win+R”快捷键并运行powershell快速进入PowerShell终端。运行powershell3. 执行pip命令安装在终端中执行前述命令安装SoCube V1.0，其中对国内用户推荐使用清华大学镜像源加速软件下载。当看到“Successfully installed *** socube-1.0”即表示下载安装成功。安装成功后继续在当前终端输入socube -v可以看到软件版本提示。国内用户推荐使用-i参数指定(https://pypi.tuna.tsinghua.edu.cn/simple/)。pip install socube==1.1 -f https://pypi.tuna.tsinghua.edu.cn/simple/ 4. 关于PyTorch的注意事项虽然它还在执行pip install socube时自动安装，但有些镜像的版本可能是cpu版本，因此建议用户检查一下安装的版本是否支持gpu（在正确配置GPU与CUDA时torch.cuda.is_available()会是True）。建议从pytorch官方网站或pytorch官方的特定pip源下载torch。pip install torch==1.8.1+cu111 torchvision==0.9.1+cu111 -f https://download.pytorch.org/whl/torch_stable.html sudo docker pull gcszhn/socube:latest Docker是一种容器化的技术，它将软件隔离在一个沙盒中，称之为容器。容器与物理设备（称为容器的宿主机）之间、容器与容器之间均为相互隔离的状态。容器内拥有应用运行的完整软件环境而完全不依赖于宿主机的软件环境。容器可以作为镜像发布并在安装有docker的设备之间共享而无需额外的安装。SoCube已经构建了docker镜像，并发布在Docker Hub。已经安装docker的用户可以在终端中执行上述命令获取SoCube。此外，有兴趣的用户可以自己打包一个自定义的docker镜像，Dockerflie已经开源提供。git clone https://github.com/GCS-ZHN/socube.git cd socube sudo docker build docker -t gcszhn/socube console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"4-usage.html":{"url":"4-usage.html","title":"软件使用","keywords":"","body":"软件使用 4.1 基本使用 1. 准备输入数据的格式 SoCube的数据输入是scRNA-seq的UMI计数矩阵，其行为细胞，列为基因，值为UMI计数。SoCube接受两种数据格式：（1）Python pandas库保存的HDF5格式DataFrame对象；（2）Python anndata库保存的H5AD格式（一种定制化的HDF5格式）AnnData对象。从事单细胞组学领域研究的人都具有一定的数据处理基础，因此本手册不具体介绍如何从其他格式转化为上述格式。 2. 运行SoCube SoCube和前面提到的pip一样，运行于终端下，这样的优势在于可以运行在很多没有GUI页面的服务器上，而不受GUI限制。假设输入文件为\"D:\\data\\pbmc-1C-dm.h5ad\"，则可以在终端输入下面命令运行软件，然后就会看到软件启动并在终端输出日志。参数-i（或者--input）表示指定输入文件。 socube --input \"D:\\data\\pbmc-1C-dm.h5ad\" 启动socube 等待软件运行完毕，二聚体检测结果以及中间文件默认会和输入文件放在一起，产生embedding、plots、models、outputs这几个文件夹。其中最终结果在“outputs/你的模型ID/”文件夹下以“final_result”开头的CSV文件中。用Excel电子表格软件打开，可以看到其有下图三列。第一列是输入数据的细胞样本名称，由用户的输入决定；第二列是SoCube预测该样本为二聚体的概率值，大小介于0~1之间；第三列是SoCube基于用户给定概率阈值或者默认阈值0.5得出的类型预测，singlet即单体正常细胞，doublet即二聚体。用户既可以使用概率值进行后续自定义筛选，也可以利用第三列进行直接筛选。 final_result的的CSV文件 4.2 GPU加速运算 如果用户拥有独立NVIDIA显卡并配置了正确的CUDA，会收到“Using CPU training, but GPU is available, specify ‘—gpu-ids’ to use GPU”的提示。用户只需要在前述命令的基础上，增加指定参数“—gpu-ids”来指定要使用的GPU。GPU的ID可以在前面说到的nvidia-smi命令输出中看到，0,1,2，…分别表示第1,2,3…块GPU（多块的GPU的情况下） socube -i \"D:\\data\\pbmc-1C-dm.h5ad\" --gpu-ids \"0,1\" 4.3 基于docker的使用 和前面pip安装后使用本质上一样的，但需要通过docker来启动并进入容器，因此有额外步骤docker run启动容器以及docker exec进入容器。其中“-v”、“--gpus”，“--name”都是docker run命令的启动参数，“-v”参数将外部文件夹挂载到docker容器内部路径，请务必不要忘了加这个参数。因为socube读取的是docker容器内的文件路径。“--gpus”参数负责对容器使用gpu数量进行授权。进入容器后即可正常使用socube命令。 PowerShellBash# 创建容器 docker run -v D:/data:/workspace/datasets ` –gpus all ` –name socube ` gcszhn/socube:latest # 进入容器 docker exec -it socube bash # 创建容器 sudo docker run -v /data:/workspace/datasets \\ –gpus all \\ –name socube \\ gcszhn/socube:latest # 进入容器 sudo docker exec -it socube bash 其中“gcszhn/socube:latest”是镜像名称，前面的是docker启动参数，包括文件夹映射和GPU挂载，后面即SoCube的参数，使用与前文一致。用户可以通过docker images来查看镜像名称。 可用镜像 4.4 colab使用 谷歌提供了一个免费的带有GPU的在线机器学习平台colab。用户可以上传socube_colab.ipynb（在本项目的开源仓库中提供了）和scRNA-seq数据到你的google drive，并使用其进行GPU加速预测。(温馨提示：需要在notebook设置里面选择启用GPU，默认是CPU的) 4.5 多进程训练 在内存与显存都充足的情况下，用户可以使用--enable-multiprocess参数来启用多进程训练加速，充分发挥现代CPU的多核计算优势。 socube -i your_sc.h5ad -o your_sc --gpu-ids 0 --enable-multiprocess console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"5-problem-solution.html":{"url":"5-problem-solution.html","title":"问题解决","keywords":"","body":"问题解决 5.1 第三方库lapjv报错 lapjv是socube不可或缺的依赖包，是实现J-V算法的重要工具。更多问题可以去其官方仓库src-d/lapjv。 1. numpy缺失 在安装某些版本的lapjv依赖项之前，你需要预先安装numpy（否则你会看到ModuleNotFoundError的错误。没有名为numpy的模块），这是因为这些版本，如v1.3.1，在setup.py中直接import numpy。setup.py是python安装包的执行文件，因此会导致安装失败。 import platform from setuptools import setup, Extension import numpy CXX_ARGS = { \"Darwin\": [\"-std=c++11\", \"-march=native\", \"-ftree-vectorize\"], \"Linux\": [\"-fopenmp\", \"-std=c++11\", \"-march=native\", \"-ftree-vectorize\"], \"Windows\": [\"/openmp\", \"/std:c++latest\", \"/arch:AVX2\"] } 2. RuntimeError: module compiled against API 安装lapjv的二进制版本（wheel），使用时可能存在以下RuntimeError。这是因为出版商用来编译lapjv的C库API版本与当前安装的numpy不同。 RuntimeError: module compiled against API version 0xf but this version of numpy is 0xe 有两种解决方法，如下: 源码安装lapjv，使其使用现在安装的numpy进行重新编译。注意使用的C++编译器需要支持setup.py中CXX_ARGS定义的C++版本，例如“-std=c++11”。最新版的lapjv需要使用\"-std=c++17\"。因此对没有基础的用户具有一定技术挑战。另外源码安装需要提供cpp库的依赖，对于windows来说，可以安装完整的visual studio 2019，或者直接下载构建工具。下载和安装完成后，重启电脑即可使用。pip install lapjv --no-binary lapjv 安装对应版本的numpy，不过可能会和其他包的依赖numpy版本发生冲突。 5.2 第三方库pytables出错 该库是pandas库的to_hdf API的依赖库。该包的某些版本缺少所需的动态C库，如tables-3.7.0-cp38-cp38-win_amd64，你可以尝试安装PyPi中列出的其他版本来解决。其他问题，你可以查看它的官方GitHub仓库。 Traceback (most recent call last): File \"c:\\Users\\zhang\\anaconda3\\envs\\socube_test\\lib\\site-packages\\pandas\\compat\\_optional.py\", line 138, in import_optional_dependency module = importlib.import_module(name) File \"c:\\Users\\zhang\\anaconda3\\envs\\socube_test\\lib\\importlib\\__init__.py\", line 127, in import_module return _bootstrap._gcd_import(name[level:], package, level) File \"\", line 1014, in _gcd_import File \"\", line 991, in _find_and_load File \"\", line 975, in _find_and_load_unlocked File \"\", line 671, in _load_unlocked File \"\", line 843, in exec_module File \"\", line 219, in _call_with_frames_removed File \"c:\\Users\\zhang\\anaconda3\\envs\\socube_test\\lib\\site-packages\\tables\\__init__.py\", line 45, in from .utilsextension import get_hdf5_version as _get_hdf5_version ImportError: DLL load failed while importing utilsextension: 找不到指定的模块。 During handling of the above exception, another exception occurred: Traceback (most recent call last): File \"c:\\Users\\zhang\\anaconda3\\envs\\socube_test\\lib\\concurrent\\futures\\process.py\", line 239, in _process_worker r = call_item.fn(*call_item.args, **call_item.kwargs) File \"d:\\life_matters\\IDRB\\深度组学\\单细胞组学\\SoCube\\src\\socube\\utils\\concurrence.py\", line 74, in wrapper return func(*args, **kwargs) File \"d:\\life_matters\\IDRB\\深度组学\\单细胞组学\\SoCube\\src\\socube\\utils\\io.py\", line 262, in writeHdf data.to_hdf(file, key=key, mode=mode, **kwargs) File \"c:\\Users\\zhang\\anaconda3\\envs\\socube_test\\lib\\site-packages\\pandas\\core\\generic.py\", line 2763, in to_hdf pytables.to_hdf( File \"c:\\Users\\zhang\\anaconda3\\envs\\socube_test\\lib\\site-packages\\pandas\\io\\pytables.py\", line 311, in to_hdf with HDFStore( File \"c:\\Users\\zhang\\anaconda3\\envs\\socube_test\\lib\\site-packages\\pandas\\io\\pytables.py\", line 572, in __init__ tables = import_optional_dependency(\"tables\") File \"c:\\Users\\zhang\\anaconda3\\envs\\socube_test\\lib\\site-packages\\pandas\\compat\\_optional.py\", line 141, in import_optional_dependency raise ImportError(msg) ImportError: Missing optional dependency 'pytables'. Use pip or conda to install pytables. 5.3 docker镜像使用出错 1. nvidia-container-cli: initialization error docker在windows下默认依赖后端是WSL2。而较早版本的windows 10的WSL2不支持GPU，因此会收到下面的报错。 Running hook #0:: error running hook: exit status 1, stdout: , stderr: nvidia-container-cli: initialization error: driver error: failed to process request: unknown 用户可以选择升级windows 10 21H2等新版本。推荐用户在拥有GPU的linux服务器使用docker。或者用户可以选择纯CPU运行，但速度会较慢。 docker run ` -v :/workspace/datasets ` gcszhn/socube:latest ` -i datasets/ console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"6-parameters.html":{"url":"6-parameters.html","title":"参数详解","keywords":"","body":"参数详解 SoCube的所有软件参数帮助可以在终端执行socube --help得到，这里对它进行详解。socube的help文档输出会根据用户系统的语言与区域设置自动选择中文或者英文。如有必要，用户可以修改系统语言设置切换，例如linux下设置LC_ALL环境变量为en_US。 SoCube帮助 --help 简写为“-h”。获取上述的参数使用帮助。 --version 简写为“-v”，获取SoCube的版本和版权信息。 --input 简写为“-i”。如前所述，该参数用于指定数据输入文件，可以接收两种数据格式，这里不再赘述。 --output 简写为“-o”。该参数用于自定义结果的输出路径，路径不存在会自动创建。如前所述，默认情况下，结果输出会与输入文件在相同目录，用户可以使用该参数来自定义。例：--output D:/data/。 --gpu-ids 如前所述，该参数用于指定参与计算加速的GPU设备序号。可以是单个序号，也可以是以逗号分隔的多个序号，注意逗号为英文逗号且无空格，默认不设置，使用CPU。例：--gpu-ids 0,1,2。 --seed 该参数用于指定软件计算中随机过程的随机数种子，默认为不设置。例：--seed 4067。 --k 该参数用于指定模型k折交叉训练的k值，默认为5。例：--k 4。 --adj-factor 该参数二聚体表达水平的调整系数。默认情况下，假定二聚体的表达水平是单体的两倍，但实际情况存在波动，可以通过调整这个系数改变表达水平。默认为1.0。例：--adj-factor 0.8。 --dim 该参数用于指定构建特征的通道数，也是基因特征降维的目标维数，默认为10。例：--dim 5。 --cube-id 该参数用于复用此前产生的特征。所有特征会保存在embedding子目录下。该参数即为该子目录下具体特征的ID，为“XXXXXX-XXXXXX-XXX”样式的字符串。。例：--cube-id 20220704-120122-854。 --only-embedding 用户可能只是想使用SoCube表征策略，但不需要检测并移除二聚体，使用此参数即表示仅表征。 --generate-mode 二聚体的模拟生成模式，提供三种选项：balance（平衡模式，默认），heterotypic（异源二聚体优先模式）和homotypic（同源二聚体优先模式）。 --learning-rate 简写为“-lr”。人工智能深度神经网络的训练学习率。该参数对检测效果会有显著影响。默认值为1e-3，如果用户觉得有必要，可以自定义。例：--learning-rate 1e-4。 --epochs 简写为“-e”。该参数指的是神经网络训练的最大轮数。但一般而言，会在达到默认最大轮数100前完成训练。例：--epochs 50。 --train-batch-size 该参数用于指定神经网络训练的批次数据集大小，默认为64。批次数据集大小较大，训练效果往往较好，但占用CPU内存或者GPU显存较大。用户可以根据自己设备实际情况做出调整。例：--train-batch-size 32。 --valid-batch-size 与前类似，该参数用于指定神经网络验证的批次数据集大小，默认为512。因为验证过程比训练过程的内存消耗显著较小，因此默认值较大。例：--valid-batch-size 256。 --infer-batch-size 与前类似，该参数用于指定神经网络预测的批次数据集大小，默认为400。例：--infer-batch-size 256。 --threshold 简写“-t”。该参数用于指定分类二聚体与单体的概率阈值，默认为0.5。正如前面CSV结果文件的解释，大于阈值的细胞样本会被判定为二聚体。例：-t 0.5。 --enable-validation 简写“-ev”。该参数是位置参数，无后续值。使用它表示启用结果验证，该功能仅用于复现结果的评估指标。使用时要求数据输入格式为H5AD格式，且在其AnnData对象的“obs”属性中有“type”列，内容为“doublet”或“singlet”，表示该数据集的真实标注。 --enable-multiprocess 简写“-mp”。该参数是位置参数，无后续值。使用它表示启用多进程训练。此时SoCube会创建k个子进程来并行训练k个子模型（k值由—k参数指定）。多进程训练可以提高检测速度，但是属于空间换时间，会增大内存和显存开销，因此用户需要根据自己的数据集大小与内存大小判断是否开启多进程。当然用户可以调节前面的批次参数来降低内存占用。 --mail 该参数指定了用于结果通知的邮箱地址，任何支持SMTP协议的邮件供应商都可以使用，例如QQ邮箱、Gmail等。需要和后续几个邮箱参数配合使用。 --mail-server 该参数指定了邮件供应商的SMTP服务器域名。具体请咨询您所使用的邮箱供应商。例：--mail-server smtp.gmail.com。 --mail-port 该参数指定了邮件供应商的SMTP服务端口。具体请咨询您所使用的邮件供应商。例：--mail-port 994。 --mail-passwd 该参数指定了邮箱的密码。一般就是网页邮箱的登录密码，但邮件供应商另有约定的除外，具体请咨询您所使用的邮件供应商。 --enable-ssl 启用该参数代表邮件服务使用SSL加密。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"term.html":{"url":"term.html","title":"术语","keywords":"","body":"术语 术语 解释 CPU 计算机术语，计算机的中央处理单元（central process unit），也就是人们常说的计算机芯片的核心部分。负责整个计算机的调度运行。 GPU 计算机术语，计算机的图形处理单元（graphic process unit），也就是人们常说的显卡的核心部分。负责数字信号与图像模拟信号的转换，同时现代GPU可以用于人工智能深度学习模型的计算加速。 RAM 计算机术语，计算机的随机获取储存器（random access memory），也就是人们常说的内存的一种类型。可以高效访问，但无法在断电后保存数据。 pip 计算机术语，Python语言的自带包管理器，用于安装SoCube V1.0。 docker 计算机术语，一种将应用软件及其依赖软件环境与物理机隔离的技术。 SMTP 计算机术语，简易邮件传输协议（Simple Mail Transfer Protocol），一种邮件服务，邮件供应商通过支持该协议，允许来自第三方邮件客户端的操作。 scRNA-seq 生物信息学术语，高通量的单细胞核糖核酸测序（single cell RNA sequencing）。用于检测单个细胞中基因的表达情况。 CNN 人工智能术语，卷积神经网络（convolutional neural network），一种最为常见的人工智能模型类型，适用于类图像数据。SoCube正是使用CNN构建模型。 WSL 计算机术语，微软开发的linux子系统（windows subsystem linux），类似于VMare等第三方提供的虚拟机。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"reference.html":{"url":"reference.html","title":"参考资料","keywords":"","body":"参考资料 Klein AM, Mazutis L, Akartuna I et al. Droplet barcoding for single-cell transcriptomics applied to embryonic stem cells, Cell 2015;161:1187-1201. Cao J, Packer JS, Ramani V et al. Comprehensive single-cell transcriptional profiling of a multicellular organism, Science 2017;357:661-667. Gierahn TM, Wadsworth MH, 2nd, Hughes TK et al. Seq-Well: portable, low-cost RNA sequencing of single cells at high throughput, Nat Methods 2017;14:395-398. Macosko EZ, Basu A, Satija R et al. Highly Parallel Genome-wide Expression Profiling of Individual Cells Using Nanoliter Droplets, Cell 2015;161:1202-1214. Zheng GX, Terry JM, Belgrader P et al. Massively parallel digital transcriptional profiling of single cells, Nat Commun 2017;8:14049. Rosenberg AB, Roco CM, Muscat RA et al. Single-cell profiling of the developing mouse brain and spinal cord with split-pool barcoding, Science 2018;360:176-182. Xi NM, Li JJ. Benchmarking Computational Doublet-Detection Methods for Single-Cell RNA Sequencing Data, Cell Syst 2021;12:176-194 e176. console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}